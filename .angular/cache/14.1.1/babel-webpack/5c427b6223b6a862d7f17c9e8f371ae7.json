{"ast":null,"code":"import { DistanceBearing } from './distance-bearing';\nexport class Geodetic {\n  constructor() {\n    this.latitude = 0;\n    this.longitude = 0;\n  }\n\n}\nexport class Utm {\n  constructor() {\n    this.easting = 0;\n    this.northing = 0;\n    this.zone = 0;\n    this.zoneDesignator = '';\n    this.elevation = 0;\n    this.hemisphere = 'N';\n  }\n\n  toString() {\n    return this.zone + this.zoneDesignator + ' ' + this.easting + 'E ' + this.northing + this.hemisphere;\n  }\n\n}\n/**\n * Class used to convert coordinate to/from different coordinate formats.\n *\n */\n\nexport class CoordinateConverter {\n  /**\n   * Converts a radian to degrees.\n   *\n   * @param rads Number in radians to convert.\n   * @returns {number} Returns the value in degrees.\n   */\n  static toDegrees(rads) {\n    return rads * (180.0 / Math.PI);\n  }\n  /**\n   * Converts a number in degrees to radians.\n   *\n   * @param degrees Number in rads to convert.\n   * @returns {number} Returns the value in rads.\n   */\n\n\n  static toRads(degrees) {\n    return degrees * (Math.PI / 180.0);\n  }\n  /**\n   * Converts any coordinate into UTM.\n   *\n   * @method toUTM\n   * @memberOf CoordConverter\n   * @param toConvert The coordinate to convert.\n   * @returns {Utm} Returns the converted coordinate in a Utm object.\n   */\n\n\n  static toUTM(latLo) {\n    let retval = new Utm();\n\n    if (latLo) {\n      const deg2rad = Math.PI / 180.0;\n      const equatorial_radius = 6378137.0;\n      const recepicalFlattning = 298.257223563;\n      const b = equatorial_radius * (1 - 1.0 / recepicalFlattning);\n      const secondEcc = recepicalFlattning * recepicalFlattning / (b * b) - 1;\n      const eccentricity_squared = 1 - b * b / (equatorial_radius * equatorial_radius);\n      const eccentricity_prime_squared = secondEcc;\n      const LatDegree = latLo.latitude;\n      const LongDegree = latLo.longitude;\n      let UTMEastingMeter = 0;\n      let UTMNorthingMeter = 0;\n      const k0 = 0.9996; // Make sure the longitude is between -180.00 .. 179.9\n\n      const LongTemp = LongDegree + 180 - (LongDegree + 180) / 360 * 360 - 180; // -180.00 .. 179.9;\n\n      const LatRad = LatDegree * deg2rad;\n      const LongRad = LongTemp * deg2rad;\n      let ZoneNumber = (LongTemp + 180) / 6 + 1;\n      if (LatDegree >= 56.0 && LatDegree < 64.0 && LongTemp >= 3.0 && LongTemp < 12.0) ZoneNumber = 32; // Special zones for Svalbard\n\n      if (LatDegree >= 72.0 && LatDegree < 84.0) {\n        if (LongTemp >= 0.0 && LongTemp < 9.0) ZoneNumber = 31;else if (LongTemp >= 9.0 && LongTemp < 21.0) ZoneNumber = 33;else if (LongTemp >= 21.0 && LongTemp < 33.0) ZoneNumber = 35;else if (LongTemp >= 33.0 && LongTemp < 42.0) ZoneNumber = 37;\n      }\n\n      const LongOriginRad = ((ZoneNumber - 1) * 6 - 180 + 3) * deg2rad; // + 3 puts origin in middle of zone\n\n      const UTMZone = CoordinateConverter.UTMLetterDesignator(LatDegree); // compute the UTM Zone from the latitude and longitude\n      // sprintf(UTMZone, \"%d%c\", ZoneNumber, UTMLetterDesignator(LatDegree));\n\n      const N = equatorial_radius / Math.sqrt(1 - eccentricity_squared * Math.sin(LatRad) * Math.sin(LatRad));\n      const T = Math.tan(LatRad) * Math.tan(LatRad);\n      const C = eccentricity_prime_squared * Math.cos(LatRad) * Math.cos(LatRad);\n      const A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n      const M = equatorial_radius * ((1 - eccentricity_squared / 4 - 3 * eccentricity_squared * eccentricity_squared / 64 - 5 * eccentricity_squared * eccentricity_squared * eccentricity_squared / 256) * LatRad - (3 * eccentricity_squared / 8 + 3 * eccentricity_squared * eccentricity_squared / 32 + 45 * eccentricity_squared * eccentricity_squared * eccentricity_squared / 1024) * Math.sin(2 * LatRad) + (15 * eccentricity_squared * eccentricity_squared / 256 + 45 * eccentricity_squared * eccentricity_squared * eccentricity_squared / 1024) * Math.sin(4 * LatRad) - 35 * eccentricity_squared * eccentricity_squared * eccentricity_squared / 3072 * Math.sin(6 * LatRad));\n      UTMEastingMeter = k0 * N * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccentricity_prime_squared) * A * A * A * A * A / 120) + 500000.0;\n      UTMNorthingMeter = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccentricity_prime_squared) * A * A * A * A * A * A / 720));\n\n      if (LatDegree < 0) {\n        UTMNorthingMeter += 10000000.0; //10000000 meter offset for southern hemisphere\n      } // Southern hemisphere?\n\n\n      let hemi = CoordinateConverter.UTM_HEMI_NORTHERN;\n\n      if (LatDegree < 0) {\n        hemi = CoordinateConverter.UTM_HEMI_SOUTHERN;\n      }\n\n      const easting = Math.round(UTMEastingMeter);\n      const northing = Math.round(UTMNorthingMeter);\n      retval.easting = easting;\n      retval.elevation = 0;\n      retval.hemisphere = hemi;\n      retval.northing = northing;\n      retval.zone = ZoneNumber;\n      retval.zoneDesignator = UTMZone;\n    }\n\n    return retval;\n  }\n  /**\n   *\n   * @param LatDegree\n   * @returns\n   */\n\n\n  static UTMLetterDesignator(LatDegree) {\n    let LetterDesignator = '';\n    if (84 >= LatDegree && LatDegree >= 72) LetterDesignator = \"X\";else if (72 > LatDegree && LatDegree >= 64) LetterDesignator = \"W\";else if (64 > LatDegree && LatDegree >= 56) LetterDesignator = \"V\";else if (56 > LatDegree && LatDegree >= 48) LetterDesignator = \"U\";else if (48 > LatDegree && LatDegree >= 40) LetterDesignator = \"T\";else if (40 > LatDegree && LatDegree >= 32) LetterDesignator = \"S\";else if (32 > LatDegree && LatDegree >= 24) LetterDesignator = \"R\";else if (24 > LatDegree && LatDegree >= 16) LetterDesignator = \"Q\";else if (16 > LatDegree && LatDegree >= 8) LetterDesignator = \"P\";else if (8 > LatDegree && LatDegree >= 0) LetterDesignator = \"N\";else if (0 > LatDegree && LatDegree >= -8) LetterDesignator = \"M\";else if (-8 > LatDegree && LatDegree >= -16) LetterDesignator = \"L\";else if (-16 > LatDegree && LatDegree >= -24) LetterDesignator = \"K\";else if (-24 > LatDegree && LatDegree >= -32) LetterDesignator = \"J\";else if (-32 > LatDegree && LatDegree >= -40) LetterDesignator = \"H\";else if (-40 > LatDegree && LatDegree >= -48) LetterDesignator = \"G\";else if (-48 > LatDegree && LatDegree >= -56) LetterDesignator = \"F\";else if (-56 > LatDegree && LatDegree >= -64) LetterDesignator = \"E\";else if (-64 > LatDegree && LatDegree >= -72) LetterDesignator = \"D\";else if (-72 > LatDegree && LatDegree >= -80) LetterDesignator = \"C\";else LetterDesignator = \"Z\"; //This is here as an error flag to show that the Latitude is outside the UTM limits\n\n    return LetterDesignator;\n  }\n  /**\n   * Determines the distance in meters and bearing in degrees from one location to another.\n   * CoordinateConverter is the Vincenty algorithm and was borrowed from:\n   *\n   * http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n   *\n   * which is based on:\n   *  T Vincenty, \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application\n   *       of nested equations\", Survey Review, vol XXIII no 176, 1975\n   *       http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\n   *\n   * @method distanceTo\n   * @memberOf CoordConverter\n   * @param p1 The initial point in coord.Geodetic\n   * @param p2 The final point in coord.Geodetic\n   * @returns {coord.DistanceBearing} Returns the distance and bearing from the first point to the second.\n   * @throws {Error} Thrown if the formula failed to converge.\n   */\n\n\n  static distanceTo(p1, p2) {\n    const retval = new DistanceBearing();\n    const φ1 = CoordinateConverter.toRads(p1.latitude);\n    const λ1 = CoordinateConverter.toRads(p1.longitude);\n    const φ2 = CoordinateConverter.toRads(p2.latitude);\n    const λ2 = CoordinateConverter.toRads(p2.longitude);\n    const a = CoordinateConverter.wgs84SemiMajorAxis;\n    const b = CoordinateConverter.mgs84SemiMinorAxis;\n    const f = (a - b) / a; // Flattening\n\n    const L = λ2 - λ1;\n    const tanU1 = (1 - f) * Math.tan(φ1);\n    const cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);\n    const sinU1 = tanU1 * cosU1;\n    const tanU2 = (1 - f) * Math.tan(φ2);\n    const cosU2 = 1 / Math.sqrt(1 + tanU2 * tanU2);\n    const sinU2 = tanU2 * cosU2;\n    let sinλ = 0;\n    let cosλ = 0;\n    let sinSqσ = 0;\n    let sinσ = 0;\n    let cosσ = 0;\n    let σ = 0;\n    let sinα = 0;\n    let cosSqα = 0;\n    let cos2σM = 0;\n    let C = 0;\n    let λ = L;\n    let λʹ = 0;\n    let iterations = 0;\n\n    do {\n      sinλ = Math.sin(λ);\n      cosλ = Math.cos(λ);\n      sinSqσ = cosU2 * sinλ * (cosU2 * sinλ) + (cosU1 * sinU2 - sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\n      sinσ = Math.sqrt(sinSqσ); // co-incident points\n\n      if (sinσ === 0) {\n        retval.distance = retval.initialBearing = retval.finalBearing = 0;\n        return retval;\n      }\n\n      cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;\n      σ = Math.atan2(sinσ, cosσ);\n      sinα = cosU1 * cosU2 * sinλ / sinσ;\n      cosSqα = 1 - sinα * sinα;\n      cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα; // equatorial line: cosSqα=0 (§6)\n\n      if (isNaN(cos2σM)) {\n        cos2σM = 0;\n      }\n\n      C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\n      λʹ = λ;\n      λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n    } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 200);\n\n    if (iterations >= 200) {\n      throw new Error('Formula failed to converge');\n    }\n\n    const uSq = cosSqα * (a * a - b * b) / (b * b);\n    const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n    const Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) - B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\n    const s = b * A * (σ - Δσ);\n    let α1 = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\n    let α2 = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 * cosλ);\n    α1 = (α1 + 2 * Math.PI) % (2 * Math.PI); // normalize to 0...360\n\n    α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalize to 0...360\n\n    retval.distance = s;\n    retval.initialBearing = CoordinateConverter.toDegrees(α1);\n    retval.finalBearing = CoordinateConverter.toDegrees(α2);\n    return retval;\n  }\n\n} // Semi-major axis for WGS84.\n\nCoordinateConverter.wgs84SemiMajorAxis = 6378137.0; // Semi-minor axis for WGS84.\n\nCoordinateConverter.mgs84SemiMinorAxis = CoordinateConverter.wgs84SemiMajorAxis * (1 - 1.0 / 298.257223563); // First eccentricity for WGS84.\n\nCoordinateConverter.firstEccentricity = 1 - CoordinateConverter.mgs84SemiMinorAxis * CoordinateConverter.mgs84SemiMinorAxis / (CoordinateConverter.wgs84SemiMajorAxis * CoordinateConverter.wgs84SemiMajorAxis); // Second eccentricity for WGS84.\n\nCoordinateConverter.secondEccentricity = CoordinateConverter.wgs84SemiMajorAxis * CoordinateConverter.wgs84SemiMajorAxis / (CoordinateConverter.mgs84SemiMinorAxis * CoordinateConverter.mgs84SemiMinorAxis) - 1; // We'll use this a lot so calculate it up front.\n\nCoordinateConverter.PI_OVER_2 = Math.PI / 2.0; // cosine of 67.5 degrees.\n\nCoordinateConverter.COS_67P5 = 0.38268343236508977; // Toms region 1 constant.\n\nCoordinateConverter.AD_C = 1.0026000; // The set of zone characters for UTM and MGRs conversions\n\nCoordinateConverter.GC_CHAR = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; // Supports conversions to UTM\n\nCoordinateConverter.GC_GZ_BASE = [-1, -1, 1116918, 2008494, 2899535, 3789860, 4679346, 5567932, -1, 6455631, 7342522, 8228746, 9114496, 0, -1, 885504, 1771254, 2657478, 3544369, 4432068, 5320654, 6210140, 7100465, 7991506, -1, -1]; // Supports conversions to UTM\n\nCoordinateConverter.GC_CHAR_POS = [0, 1, 2, 3, 4, 5, 6, 7, 255, 8, 9, 10, 11, 12, 255, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // Supports conversions to MGRS\n\nCoordinateConverter.SP_OFF = 0;\nCoordinateConverter.UTM_HEMI_NORTHERN = 'N';\nCoordinateConverter.UTM_HEMI_SOUTHERN = 'S';","map":null,"metadata":{},"sourceType":"module"}